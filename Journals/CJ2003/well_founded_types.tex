%%-*-latex-*-

In this section we tackle the finiteness problem of \ASN types. The
solution shall be used later for solving the same problem over
subtypes. At this point, let us notice again that \emph{some types
have only infinite values}. For instance, \texttt{\small T ::= SET}
\verb+{+\texttt{a} \texttt{\small T}\verb+}+ is forbidden by the
standard since the current encoding rules cannot handle values of such
a type (the encoding engine generated by the \ASN compiler would loop
forever). Let us call \emph{well-founded} a \core type which has at
least one finite value. Let $\TypeEnv$ be a type environment. Let us
write $\TypeEnv \Vdash \T$ if and only if $\T$ is well-founded in
$\TypeEnv$.\footnote{It is possible to give a formal and direct
definition of this concept. Here is a sketch. First, we define a
function $h_{\TypeEnv} : \V \rightarrow \mathbb{N} \cup \{+\infty\}$,
which computes the maximum height of the abstract syntax tree
corresponding to a value in the environment $\TypeEnv$, modulo
references: an empty tree, a leaf and a non-cyclic reference add no
height (the reference is unfolded then); a node adds a height of 1,
and a cyclic reference returns $+\infty$. Second, we define a
predicate $\TypeEnv \vdash v : \T$, read: `$v$ is of type \T{} in the
environment $\TypeEnv$'. Then \T{} is well-founded if, and only if, $\exists v \in
\V$ such as $h_{\TypeEnv}(v) \in \mathbb{N}$ and $\TypeEnv \vdash v :
\T$. We should then prove that our forthcoming axiomatisation of
$\TypeEnv \Vdash \T$ is equivalent to $\exists v \in \V$ such as
$h_{\TypeEnv}(v) \in \mathbb{N}$ and $\TypeEnv \vdash v : \T$.} For
technical reasons, we need another definition: $\TypeEnv, \Path \Vdash
\T$ where $\Path$ (read `history') is a set of type reference
names. These names correspond to the previously encountered type
references: they allow some recursions to be detected and rejected. By
definition: $\TypeEnv \Vdash \T$ is equivalent to $\TypeEnv,
\varnothing \Vdash \T$. This latter relationship is the smallest one
induced by the closure of the following inference rules. Please note
that we use `$x \lhd y$' as a short-hand for `$\ocamlkwd{match} \,\, x
\,\, \ocamlkwd{with} \,\, y \rightarrow \ocamlkwd{true}$' in OCaml
(projection), and \ocamlkwd{as} has the same meaning as in OCaml
(pattern binder):
\begin{mathpar}
\inferrule*[right=Axioms]
  {\neg(\T \lhd \TRef \, \wildcard 
                \mid \kwdCHOICE \, \wildcard)\\
   \neg(\T \lhd \kwdSET \, \wildcard 
                \mid \kwdSEQUENCE \, \wildcard)}
  {\TypeEnv, \Path \Vdash \T}
\end{mathpar}
The rule \textsf{Axioms} states that the types that differ from \TRef,
\kwdCHOICE, \kwdSET{} and \kwdSEQUENCE{} are always well-founded,
e.g. \texttt{\small T ::= SET OF T} is well-founded.
\begin{mathpar}
\inferrule*[right=Ref]
  {x \not\in \Path\\
   \TypeEnv(x) \lhd (\T,\sigma)\\
   \TypeEnv, \{x\} \cup \Path \Vdash \T}
  {\TypeEnv, \Path \Vdash \TRef \, (x)}
\end{mathpar}
The rule \RefTirName{Ref} handles the case of the type references. The
first premise is a look-up in the history to check for a previous
occurrence of the reference name: if present, the type is rejected,
like \texttt{\small T ::= CHOICE} \verb+{+\texttt{a} \texttt{\small
T}\verb+}+. The second premise is a look-up in the specification for
the definition of the referenced type. The last premise is the
checking of the referenced type.
\begin{mathpar}
\inferrule*[right=Choice]
  {\TypeEnv, \Path \Vdash \FieldEnv{}(l)}
  {\TypeEnv, \Path \Vdash \kwdCHOICE \, \FieldEnv{\{l\} \disjunion \Labels}}
\end{mathpar}
In the rule \RefTirName{Choice}, we use the the symbol $\disjunion$ for
the disjoint set union. This rule handles the case of \kwdCHOICE{}
types. The first premise is the projection of a component, which is
checked in the following premise: a \kwdCHOICE{} is well-founded if
and only if one of its component is well-founded, e.g. \texttt{\small
T ::= CHOICE} \verb+{+\texttt{a} \texttt{\small T,} \texttt{b}
\texttt{\small INTEGER}\verb+}+.
\begin{mathpar}
\inferrule*[right=Seq]
  {\TypeEnv, \Path \Vdash \kwdSET \,\, \CompEnv{}} 
  {\TypeEnv, \Path \Vdash \kwdSEQUENCE \,\, \CompEnv{}}
\end{mathpar}
The rule \RefTirName{Seq} simply states that the proof of well-foundedness
of a \kwdSEQUENCE{} type is the same as the one for the \kwdSET{} with
the same components. 
\begin{mathpar}
\inferrule*[right=$\varnothing$-Set]
  {}
  {\TypeEnv, \Path \Vdash \kwdSET \,\, \{\}}
\end{mathpar}
The axiom \textsf{$\varnothing$-Set} says that an
empty \kwdSET{} type is well-founded. 
\begin{mathpar}
\inferrule*[right=SetOpt]
  {\CompEnv{}(l) \lhd (\T', \Some \, \kwdOPTIONAL)\\
   \TypeEnv, \Path \Vdash \kwdSET \,\, \CompEnv{\Labels}}
  {\TypeEnv, \Path \Vdash \kwdSET \,\, \CompEnv{\{l\} \disjunion \Labels}}
\end{mathpar}
The rule \RefTirName{SetOpt} applies when a component is marked as
\kwdOPTIONAL. In this case, it is ignored, and the remaining
components are checked. Indeed, an optional component can be absent in
the value definition, thus any recursion throughout it is valid.
\begin{mathpar}
\inferrule*[right=SetDef]
  {\CompEnv{}(l) \lhd (\T', \None \mid \Some \, (\kwdDEFAULT \wildcard))\\
   \TypeEnv, \Path \Vdash \T'
   \and
   \TypeEnv, \Path \Vdash \kwdSET \,\, \CompEnv{\Labels}
  }
  {\TypeEnv, \Path \Vdash \kwdSET \,\, \CompEnv{\{l\} \disjunion \Labels}}
\end{mathpar}
The rule \RefTirName{SetDef} applies when a component is not marked as
\kwdOPTIONAL{} (first premise): then the type of this
component is checked. This allows to reject for instance
\texttt{\small T ::= SET} \verb+{+\texttt{a} \texttt{\small
T}\verb+}+. The last premise corresponds to the checking of the
remaining components. 

It is not too difficult to see that if a type satisfies our formal
criterion, then it has at least one finite value (the proof tree is
isomorphic to value construction steps, i.e. each judgement $\TypeEnv
\Vdash \T$ can be associated to a value of \T). Also, our inference
system can be considered as an algorithm: just consider the rules and
the premises ordered as they are written. Also, the implicit
existential quantifiers (on $l$ in rules \RefTirName{Choice},
\RefTirName{SetOpt} and \RefTirName{SetDef}) are easy to make
constructive: simply try the components in the given order.

It is worth remarking that the well-foundedness of a type does not
imply that its subtypes have at least a finite value. For example,
\texttt{\small T ::= CHOICE} \verb+{+\texttt{a} \texttt{\small T,}
\texttt{b} \texttt{\small REAL}\verb+}+ is well-founded, but
\texttt{\small U ::= T (WITH COMPONENTS} \verb+{+\texttt{\small ...,}
\texttt{b} \texttt{\small ABSENT}\verb+}+\texttt{)} has no finite
value. That is why the relationship $\Vdash$ will be reused in the
forthcoming constraint-collecting algorithm, which assumes that all
the types in \core are well-founded.
